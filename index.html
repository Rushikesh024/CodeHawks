<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive C Pattern Printing Guide</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Chosen Palette: Warm Neutrals -->
    <!-- Application Structure Plan: The application is designed as a single-page interactive guide with a tab-based navigation system ('Home', 'Core Concepts', 'Pattern Explorer', 'Best Practices'). This non-linear structure allows users to freely navigate to the content they need, whether they are beginners starting with concepts or experienced users looking for specific pattern code. The core of the app is the 'Pattern Explorer', which features a sidebar for pattern selection and a main content area for displaying a dynamic preview, the C code, and a logical explanation. This design was chosen to transform passive reading into an active, hands-on learning experience, which is more effective for understanding programming concepts. -->
    <!-- Visualization & Content Choices: Report Info -> Goal -> Viz/Presentation Method -> Interaction -> Justification -> Library/Method. 1. Pattern Shapes -> Goal: Visualize -> Method: Dynamically generated text in a <pre> tag -> Interaction: A slider controls the number of rows, causing the JS generator function to re-render the text-based pattern. -> Justification: Provides instant, tangible feedback on how code parameters affect output, which is superior to static images. -> Method: Vanilla JS. 2. Core Concepts/Best Practices -> Goal: Organize & Inform -> Method: Styled cards and accordions. -> Interaction: Click to expand/collapse. -> Justification: Breaks down dense text into digestible, user-triggered chunks, preventing information overload. -> Method: HTML/CSS/JS. 3. Code Snippets -> Goal: Inform/Educate -> Method: Styled <pre><code> blocks. -> Interaction: Dynamically updated based on pattern selection. -> Justification: Presents code in a familiar, readable format for developers. -> Method: Vanilla JS. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body { font-family: 'Inter', sans-serif; }
        .tab-active { border-color: #4f46e5; color: #4f46e5; background-color: #eef2ff; }
        .tab-inactive { border-color: transparent; color: #4b5563; }
        .content-section { display: none; }
        .content-section.active { display: block; }
        .pattern-btn-active { background-color: #4f46e5; color: white; }
        .pattern-btn-inactive { background-color: #e5e7eb; color: #374151; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f5f9; }
        ::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
</head>
<body class="bg-slate-50 text-slate-800">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-indigo-600">C Pattern Printing</h1>
            <p class="mt-2 text-lg text-slate-600">An Interactive Guide to Algorithmic Visualization</p>
        </header>

        <nav class="mb-8 border-b border-slate-200">
            <ul class="flex flex-wrap -mb-px text-sm font-medium text-center">
                <li class="mr-2">
                    <button class="nav-tab inline-block p-4 border-b-2 rounded-t-lg" data-tab="home">Home</button>
                </li>
                <li class="mr-2">
                    <button class="nav-tab inline-block p-4 border-b-2 rounded-t-lg" data-tab="concepts">Core Concepts</button>
                </li>
                <li class="mr-2">
                    <button class="nav-tab inline-block p-4 border-b-2 rounded-t-lg" data-tab="explorer">Pattern Explorer</button>
                </li>
                <li>
                    <button class="nav-tab inline-block p-4 border-b-2 rounded-t-lg" data-tab="best-practices">Best Practices</button>
                </li>
            </ul>
        </nav>

        <main>
            <!-- Home Section -->
            <section id="home" class="content-section active">
                <div class="bg-white p-6 md:p-8 rounded-xl shadow-sm">
                    <h2 class="text-2xl font-bold text-indigo-700 mb-4">Welcome to the Pattern Printing Playground</h2>
                    <div class="space-y-4 text-slate-700 leading-relaxed">
                        <p>Pattern printing in C is more than just a visual exercise; it's a fundamental step in mastering programming logic. This interactive guide is designed to help you understand the core concepts of loops and conditional statements in a tangible, hands-on way. By generating these patterns, you build crucial problem-solving skills and a deeper intuition for how algorithms work.</p>
                        <p>This skill is essential for beginners and is a common part of technical assessments because it clearly demonstrates your ability to translate a requirement into functional code. Here, you can explore various patterns, see the code that creates them, and understand the logic behind each one. Use the <span class="font-semibold text-indigo-600">Pattern Explorer</span> to experiment and build your confidence!</p>
                    </div>
                </div>
            </section>

            <!-- Core Concepts Section -->
            <section id="concepts" class="content-section">
                <div class="bg-white p-6 md:p-8 rounded-xl shadow-sm">
                    <h2 class="text-2xl font-bold text-indigo-700 mb-6">Fundamental Building Blocks</h2>
                     <p class="mb-8 text-slate-600">To create any pattern, you need to master three fundamental concepts in C. These are the tools that give you precise control over what gets printed and where. Understanding how they work together is the key to unlocking any pattern design.</p>
                    <div class="grid md:grid-cols-3 gap-6">
                        <div class="bg-slate-50 p-6 rounded-lg border border-slate-200">
                            <h3 class="text-xl font-semibold mb-2 text-slate-800">1. Loops (`for`, `while`)</h3>
                            <p class="text-slate-600">Loops are the engine of repetition. They execute a block of code multiple times, which is essential for building patterns row by row. The `for` loop is most common here because it neatly packages the initialization, condition, and increment steps required to control the number of iterations.</p>
                        </div>
                        <div class="bg-slate-50 p-6 rounded-lg border border-slate-200">
                            <h3 class="text-xl font-semibold mb-2 text-slate-800">2. Nested Loops</h3>
                            <p class="text-slate-600">This is the key to 2D patterns. A loop inside another loop allows you to work with rows and columns. The outer loop typically controls the rows, and for each row, the inner loop runs completely to handle the columns, printing the characters for that specific line.</p>
                        </div>
                        <div class="bg-slate-50 p-6 rounded-lg border border-slate-200">
                            <h3 class="text-xl font-semibold mb-2 text-slate-800">3. Conditionals (`if/else`)</h3>
                            <p class="text-slate-600">While loops build the grid, conditionals decide what to print in each cell. They are crucial for complex designs like hollow shapes or patterns with alternating characters. By checking the current row or column index, you can selectively print a star, a number, or just a space.</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Pattern Explorer Section -->
            <section id="explorer" class="content-section">
                <div class="flex flex-col md:flex-row gap-8">
                    <aside class="md:w-1/4">
                        <div class="bg-white p-4 rounded-xl shadow-sm">
                            <h3 class="font-bold text-lg mb-4 text-indigo-700 px-2">Select a Pattern</h3>
                            <div id="pattern-menu" class="space-y-1"></div>
                        </div>
                    </aside>
                    <div class="md:w-3/4">
                        <div class="bg-white p-6 md:p-8 rounded-xl shadow-sm">
                            <div id="explorer-content">
                                <p class="text-center text-slate-500">Select a pattern from the menu to begin.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Best Practices Section -->
            <section id="best-practices" class="content-section">
                 <div class="bg-white p-6 md:p-8 rounded-xl shadow-sm">
                    <h2 class="text-2xl font-bold text-indigo-700 mb-6">Algorithmic Strategy & Tips</h2>
                     <p class="mb-8 text-slate-600">Writing code to generate patterns is a great way to practice your problem-solving process. Following a structured approach will not only help you get the right output but also write cleaner, more understandable code. Here are some key strategies and common pitfalls to be aware of.</p>
                    <div id="accordion" class="space-y-3">
                        <!-- Accordion items will be injected by JS -->
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const patterns = [
                {
                    name: 'Right Half Pyramid',
                    category: 'Star Patterns',
                    id: 'star-right-pyramid',
                    explanation: 'The logic is straightforward. The outer loop iterates through the rows. The inner loop iterates from 1 up to the current row number (`i`), printing a star each time. This ensures that row 1 has 1 star, row 2 has 2 stars, and so on.',
                    generator: (rows) => {
                        let output = '';
                        for (let i = 1; i <= rows; i++) {
                            output += ' '.repeat(rows - i);
                            for (let j = 1; j <= i; j++) { output += '* '; }
                            output += '\n';
                        }
                        return output;
                    },
                    getCode: (rows) => `
#include <stdio.h>

int main() {
    int rows = ${rows};
    for (int i = 1; i <= rows; i++) {
        for (int j = 1; j <= i; j++) {
            printf("* ");
        }
        printf("\\n");
    }
    return 0;
}`
                },
                {
                    name: 'Full Pyramid',
                    category: 'Star Patterns',
                    id: 'star-full-pyramid',
                    explanation: 'This pattern requires three loops. The outer loop controls the rows. The first inner loop prints the leading spaces needed for alignment, which decrease with each row. The second inner loop prints the stars, which increase with each row.',
                    generator: (rows) => {
                        let output = '';
                        for (let i = 1; i <= rows; i++) {
                            output += ' '.repeat(rows - i);
                            for (let j = 1; j <= 2 * i - 1; j++) { output += '*'; }
                            output += '\n';
                        }
                        return output;
                    },
                    getCode: (rows) => `
#include <stdio.h>

int main() {
    int rows = ${rows};
    for (int i = 1; i <= rows; i++) {
        for (int space = 1; space <= rows - i; space++) {
            printf(" ");
        }
        for (int j = 1; j <= 2 * i - 1; j++) {
            printf("*");
        }
        printf("\\n");
    }
    return 0;
}`
                },
                {
                    name: 'Hollow Square',
                    category: 'Star Patterns',
                    id: 'star-hollow-square',
                    explanation: 'This pattern uses conditional logic inside the nested loops. An `if` statement checks if the current position is on a boundary (the first or last row, or the first or last column). If it is, a star is printed; otherwise, a space is printed, creating the hollow effect.',
                    generator: (rows) => {
                        let output = '';
                        for (let i = 1; i <= rows; i++) {
                            for (let j = 1; j <= rows; j++) {
                                if (i === 1 || i === rows || j === 1 || j === rows) {
                                    output += '* ';
                                } else {
                                    output += '  ';
                                }
                            }
                            output += '\n';
                        }
                        return output;
                    },
                    getCode: (rows) => `
#include <stdio.h>

int main() {
    int size = ${rows};
    for (int i = 1; i <= size; i++) {
        for (int j = 1; j <= size; j++) {
            if (i == 1 || i == size || j == 1 || j == size) {
                printf("* ");
            } else {
                printf("  ");
            }
        }
        printf("\\n");
    }
    return 0;
}`
                },
                {
                    name: "Floyd's Triangle",
                    category: 'Number Patterns',
                    id: 'number-floyd',
                    explanation: "Unlike other patterns, Floyd's Triangle uses a single counter variable that is declared outside the loops. This counter is incremented and printed in every iteration of the inner loop, creating a continuous sequence of numbers across all rows.",
                    generator: (rows) => {
                        let output = '';
                        let num = 1;
                        for (let i = 1; i <= rows; i++) {
                            for (let j = 1; j <= i; j++) {
                                output += `${num} `;
                                num++;
                            }
                            output += '\n';
                        }
                        return output;
                    },
                    getCode: (rows) => `
#include <stdio.h>

int main() {
    int rows = ${rows}, number = 1;
    for (int i = 1; i <= rows; i++) {
        for (int j = 1; j <= i; j++) {
            printf("%d ", number);
            number++;
        }
        printf("\\n");
    }
    return 0;
}`
                },
                 {
                    name: "Pascal's Triangle",
                    category: 'Number Patterns',
                    id: 'number-pascal',
                    explanation: "Pascal's Triangle is built using the concept of binomial coefficients. Each number is the sum of the two numbers directly above it. The code calculates this coefficient in each iteration, often using a formula like `C = C * (i - k) / k`.",
                    generator: (rows) => {
                        let output = '';
                        for (let i = 0; i < rows; i++) {
                            output += ' '.repeat(rows - i -1);
                            let coef = 1;
                            for (let j = 0; j <= i; j++) {
                                output += `${coef} `;
                                coef = coef * (i - j) / (j + 1);
                            }
                            output += '\n';
                        }
                        return output;
                    },
                    getCode: (rows) => `
#include <stdio.h>

int main() {
    int rows = ${rows}, coef = 1;
    for (int i = 0; i < rows; i++) {
        for (int space = 1; space <= rows - i; space++) {
            printf(" ");
        }
        for (int j = 0; j <= i; j++) {
            if (j == 0 || i == 0) {
                coef = 1;
            } else {
                coef = coef * (i - j + 1) / j;
            }
            printf("%d ", coef);
        }
        printf("\\n");
    }
    return 0;
}`
                },
                {
                    name: 'Alphabet Pyramid',
                    category: 'Character Patterns',
                    id: 'char-pyramid',
                    explanation: "Character patterns leverage C's ability to perform arithmetic on `char` types, which are internally represented by ASCII values. To print 'A', 'B', 'C', etc., you can simply start with `char ch = 'A'` and increment it (`ch++`) in the loop.",
                    generator: (rows) => {
                        let output = '';
                        for (let i = 0; i < rows; i++) {
                             output += ' '.repeat(rows - i - 1);
                            for (let j = 0; j <= i; j++) {
                                output += String.fromCharCode(65 + j) + ' ';
                            }
                            output += '\n';
                        }
                        return output;
                    },
                    getCode: (rows) => `
#include <stdio.h>

int main() {
    int rows = ${rows};
    for (int i = 0; i < rows; i++) {
        for (int space = 0; space < rows - i - 1; space++) {
            printf(" ");
        }
        for (int j = 0; j <= i; j++) {
            printf("%c ", 'A' + j);
        }
        printf("\\n");
    }
    return 0;
}`
                },
            ];

            const bestPractices = [
                {
                    title: 'Devising Pattern Logic',
                    content: 'Always start by drawing the pattern on paper. This helps you identify rows, columns, and any symmetries. Then, try to find a mathematical relationship between the row/column number (i, j) and what needs to be printed. For complex patterns, break them down into simpler parts (e.g., a diamond is two pyramids).'
                },
                {
                    title: 'Common Pitfalls & Errors',
                    content: 'The most common errors are "off-by-one" mistakes in loop conditions (using `<` vs. `<=`). Another frequent issue is incorrect output formatting, like forgetting the newline character `\\n` at the end of a row, or adding/missing a space in `printf("* ")`, which can ruin the alignment.'
                },
                {
                    title: 'Debugging Strategies',
                    content: 'The simplest way to debug is to use `printf` to print the values of your loop counters (`i` and `j`) inside the loops. This "trace" shows you the state of your program at each step and helps you find where the logic goes wrong. For more complex issues, using a formal debugger like GDB is a powerful alternative.'
                }
            ];

            const navTabs = document.querySelectorAll('.nav-tab');
            const contentSections = document.querySelectorAll('.content-section');
            const patternMenu = document.getElementById('pattern-menu');
            const explorerContent = document.getElementById('explorer-content');
            const accordionContainer = document.getElementById('accordion');

            let activePatternId = null;

            function switchTab(tabId) {
                navTabs.forEach(tab => {
                    if (tab.dataset.tab === tabId) {
                        tab.classList.add('tab-active');
                        tab.classList.remove('tab-inactive');
                    } else {
                        tab.classList.remove('tab-active');
                        tab.classList.add('tab-inactive');
                    }
                });
                contentSections.forEach(section => {
                    section.id === tabId ? section.classList.add('active') : section.classList.remove('active');
                });
            }

            function displayPattern(patternId) {
                activePatternId = patternId;
                const pattern = patterns.find(p => p.id === patternId);
                if (!pattern) return;

                document.querySelectorAll('.pattern-btn').forEach(btn => {
                     if (btn.dataset.id === patternId) {
                        btn.classList.add('pattern-btn-active');
                        btn.classList.remove('pattern-btn-inactive');
                    } else {
                        btn.classList.remove('pattern-btn-active');
                        btn.classList.add('pattern-btn-inactive');
                    }
                });

                explorerContent.innerHTML = `
                    <h3 class="text-2xl font-bold text-indigo-700 mb-4">${pattern.name}</h3>
                    <div class="mb-6">
                        <label for="rows-slider" class="block mb-2 font-medium text-slate-700">Number of Rows: <span id="rows-value" class="font-bold text-indigo-600">5</span></label>
                        <input id="rows-slider" type="range" min="3" max="15" value="5" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div>
                            <h4 class="font-semibold mb-2 text-slate-800">Visual Preview</h4>
                            <pre id="pattern-preview" class="bg-slate-900 text-slate-100 rounded-lg p-4 text-sm leading-relaxed overflow-x-auto" style="font-family: 'Fira Code', monospace;"></pre>
                        </div>
                        <div>
                             <h4 class="font-semibold mb-2 text-slate-800">Explanation</h4>
                             <p class="text-slate-600 bg-slate-50 p-4 rounded-lg border border-slate-200">${pattern.explanation}</p>
                        </div>
                        <div class="lg:col-span-2">
                             <h4 class="font-semibold mb-2 text-slate-800">C Code</h4>
                            <pre class="bg-slate-900 text-slate-100 rounded-lg p-4 text-sm overflow-x-auto"><code id="pattern-code" style="font-family: 'Fira Code', monospace;"></code></pre>
                        </div>
                    </div>
                `;
                
                const slider = document.getElementById('rows-slider');
                updatePatternView(parseInt(slider.value));

                slider.addEventListener('input', (e) => {
                    updatePatternView(parseInt(e.target.value));
                });
            }
            
            function updatePatternView(rows) {
                const pattern = patterns.find(p => p.id === activePatternId);
                if (!pattern) return;
                
                document.getElementById('rows-value').textContent = rows;
                document.getElementById('pattern-preview').textContent = pattern.generator(rows);
                document.getElementById('pattern-code').textContent = pattern.getCode(rows).trim();
            }

            function init() {
                // Setup Nav
                navTabs.forEach(tab => {
                    tab.addEventListener('click', () => switchTab(tab.dataset.tab));
                });
                switchTab('home');

                // Populate Pattern Menu
                const groupedPatterns = patterns.reduce((acc, p) => {
                    if (!acc[p.category]) acc[p.category] = [];
                    acc[p.category].push(p);
                    return acc;
                }, {});

                for (const category in groupedPatterns) {
                    const header = document.createElement('h4');
                    header.className = 'font-semibold text-sm text-slate-500 mt-4 mb-2 px-2 uppercase';
                    header.textContent = category;
                    patternMenu.appendChild(header);
                    groupedPatterns[category].forEach(p => {
                        const button = document.createElement('button');
                        button.textContent = p.name;
                        button.dataset.id = p.id;
                        button.className = 'pattern-btn pattern-btn-inactive w-full text-left px-3 py-2 rounded-md text-sm font-medium transition-colors duration-150';
                        button.addEventListener('click', () => displayPattern(p.id));
                        patternMenu.appendChild(button);
                    });
                }

                // Populate Accordion
                bestPractices.forEach((item, index) => {
                    const div = document.createElement('div');
                    div.className = 'border border-slate-200 rounded-lg';
                    div.innerHTML = `
                        <button class="accordion-toggle w-full flex justify-between items-center p-4 text-left font-semibold text-slate-800">
                            <span>${item.title}</span>
                            <svg class="w-5 h-5 shrink-0 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                        <div class="accordion-content p-4 pt-0 text-slate-600" style="display: none;">
                            ${item.content}
                        </div>
                    `;
                    accordionContainer.appendChild(div);
                });

                document.querySelectorAll('.accordion-toggle').forEach(button => {
                    button.addEventListener('click', () => {
                        const content = button.nextElementSibling;
                        const icon = button.querySelector('svg');
                        const isVisible = content.style.display === 'block';
                        content.style.display = isVisible ? 'none' : 'block';
                        icon.style.transform = isVisible ? 'rotate(0deg)' : 'rotate(180deg)';
                    });
                });

                // Set initial state for explorer
                if (patterns.length > 0) {
                    displayPattern(patterns[0].id);
                }
            }

            init();
        });
    </script>
</body>
</html>